declare name "Agostino Di Scipio - AUDIBLE ECOSYSTEMICS n.2 Library";
import("stdfaust.lib");

//==============================Library of functions============================

//--------------------Four variables are to be initialized prior to performance:
//VAR1
//distance (in meters) between the two farthest removed loudspeakers on the left-right axis.
var1 = 40;
//VAR2
//rough estimate of the center frequency in the spectrum of the room‚Äôs background noise (spectral centroid):
//to evaluate at rehearsal time, in a situation of "silence".
var2 = 1000;
//VAR3
//subjective estimate of how the room revereberance, valued between 0 ("no reverb") and 1 (‚Äúvery long reverb‚Äù).
var3 = 1000;
//VAR4
//distance (in meters) between the two farthest removed loudspeakers on the front-rear axis.
var4 = 12;

//-----------------------------------------------------------------------Mappers
mapsum(x,s,m) = s+(x*(m));
mapsub(x,s,m) = s-(x*(m));
mapmul(x,s,m) = m*(x+s);
mapcond(x) = select2(x>0.5,1, (1-x)*2);


//Maximum delay for the delay lines used
delMax = 2^16;

//INTEGRATOR
//returns the average absolute value over a specific time frame (one may use RMS measures, instead, or other amplitude-following methods);
//output range is [0, 1]
integrator(s) = an.amp_follower(s);

//LOCAL MAX
//returns the maximum signal amplitude (absolute value) in a given time frame;
//frame duration is dynamically adjusted: the next frame duration is set at the end of the previous frame
localmax(frame) = ba.peakholder(frame);

//Sepcific delay line with a maximum delay of 1 second
delay(del,fb) = (+ : de.delay(ma.SR,ba.sec2samp(d)))~*(fb)
with{
    d = min(0, del);
    dmax = d : ba.sec2samp : ma.np2;
};

//----------------------------------------Mathematical functions for the filters
eavg(a) = *(a) : +~*(1-a);


acor(fc) = cos(omega(fc))-1+sqrt(cosq(omega(fc))-4*cos(omega(fc))+3);

//2œÄ
twopi = 2*ma.PI;
//ùúè
tau = twopi;
//e
eu = 2.71828182845904523536028747135266249775724709369995957496696762772407663;
ecalc = _ <: (1+(1/_))^_;
//OMEGA
omega(fc) = fc*twopi/ma.SR;
//BILINEAR TRANSFORM
w(fc) = tan(ma.PI*fc/ma.SR);
//SIN^2 - COS^2
cosq(x) = cos(x)*cos(x);

//-----------------------------------------------------------------------Filters
//LOW PASS ONE POLE FILTER
lp1p(fc) = eavg(acor(fc));

//process = lp1p(23);

//HIGH PASS FILTER
hp1(fc) = _<:_-(lp1p(fc));

//process = hp1(23);

//================================sampleread

sampleread_wannabe(ratio, memchunk, x) = x <: (it.frwtable(N, S, 0.0, wIdx, _, rIdx))
                             with{
                                N = 5;
                                S = 44100; //TODO change with SR
                                rIdx = os.phasor(S, ratio);
                                wIdx = ba.period(S);
               };

sampleread(ratio, memchunk, sig) =
// delay frazionario                * crossfade
  de.fdelay(maxDelay,d,sig)         *    ma.fmin(d/xfade,1) +
  de.fdelay(maxDelay,d+bufsize,sig) * (1-ma.fmin(d/xfade,1))
with {
	maxDelay = 65536;
    bufsize = int(min(maxDelay, pm.l2s(var1)) * (memchunk) : si.smoo);
    xfade = 128;
	d = (1 - ratio : si.smoo) : (+ : +(bufsize) : fmod(_,bufsize)) ~ _;
};
//process = _ <: _,sampleread(ratio, memchunk);

//ratio = hslider("ratio", 1, 0.5, 2, 0.01);
//memchunk = hslider("memchunk", 1, 0.1, 1, 0.01);

//GRANULAR SAMPLING
//read sample sequences off subsequent buffer memory chunks, and envelopes the signal chunk with a pseudo-Gaussian envelope curve;
//the particular implementation should allow for time-stretching (slower memory pointer increments at grain level),
//as well as for "grain density" controls and slight random deviations ("jitter") on grain parameters; no frequency shift necessary

/*
Granular Sampling -
version with - Overlap Add To One - Granulator
for:
Agostino Di Scipio - AUDIBLE ECOSYSTEMICS
n.2a / Feedback Study (2003)
n.2b / Feedback Study, sound installation (2004).
*/

/*
- mem.pointer is the pointer to the next location in the memory
    buffer; in the present notation, it varies between -1 (beginning
    of buffer) and 1 (end of buffer)
- mem.pointer : timeIndex1 - a signal between -1 and -0.5

- mem.pointer.jitter is a random deviation of the current
    mem.pointer value; any viable method can be used to
    calculate the current actual value of mem.pointer
- mem.pointer.jitter: (1 - memWriteDel1) / 100

- memWriteDel1 = a signal between 0 and 1

- grain.duration: 0.023 + ((1 - memWriteDel1) / 21) s

- grain.dur.jitter is a random deviation of the current
    grain.duration value: the current actual grain duration =
    grain.duration + (rnd ‚ãÖ grain.dur.jitter(0.1) ‚ãÖ grain.duration)
- with rnd = random value in the interval [-1, 1]
- grain.dur.jitter: 0.1 - constant value

- density: cntrlLev: a signal between 0 and 1 (1 max, 0 no grains)
*/

//granular_sampling(timeIndex,memWriteDel,cntrlLev1,div) = div;

bufferDim = 512;

granular_sampling1(timeIndex,memWriteDel,cntrlLev,x) = x <: head1 + head2
    with{

        // Receive AE Controls
        mempointer = ((timeIndex+1)/2)*L;
        mempointerjitter = (1-memWriteDel)/100;
        grainduration = (0.023+((1 - memWriteDel)/21)); //sec.
        graindurjitter = 0.1;
        density = cntrlLev;

        // L = buffer dimension in seconds
        L = ma.SR*bufferDim;
        // tableMax = table Max Dimension
        tableMax = 192000*bufferDim;
        // Write index - ramp 0 to L
        wIdx = (+(1) : %(L)) ~ _ : int;
        buffer(p, x) = it.frwtable(3, tableMax, .0, wIdx, x, p);
        // Hanning window Equation
        hann(x) = sin(ma.frac(x) * ma.PI) ^ 2.0;
        // noise generation for this instance
        iNoise = no.noise;
        // Position of the grain in the Buffer
        timePhase = (mempointer)+((iNoise*mempointerjitter)*L);
        fixedDimension = ma.SR/10;
        frequency = ma.SR/(fixedDimension);
        // two Heads for the read
        // 0¬∞
        ph1 = os.phasor(1, frequency);
        // 180*
        ph2 = ma.frac(.5 + ph1);
        // Buffer positions = Position in the Buffer + Grain Read
        pos1 = ba.sAndH(ph1 < ph1', timePhase) + ph1*(fixedDimension);
        pos2 = ba.sAndH(ph2 < ph2', timePhase) + ph2*(fixedDimension);
        // Noises of this Instance
        iNoise1 = ba.sAndH(ph1 < ph1', iNoise);
        iNoise2 = ba.sAndH(ph2 < ph2', iNoise);
        // variableDimension = grain.duration(variable) + grain.dur.jitter
        graindurjitterfunc = (grainduration*1000)*(iNoise1*graindurjitter);
        variableDimension1(x) = x*((1+(grainduration*1000))+(graindurjitterfunc)) : min(1);
        variableDimension2(x) = x*((1+(grainduration*1000))+(graindurjitterfunc)) : min(1);
        head1 = hann(ph1: variableDimension1) * buffer(pos1);
        head2 = hann(ph2: variableDimension2) * buffer(pos2);
    };


granular_sampling2(timeIndex,memWriteDel,cntrlLev,x) = x <: head1 + head2
    with{

        // Receive AE Controls
        mempointer = ((timeIndex+1)/2)*L;
        mempointerjitter = (1-memWriteDel)/100;
        grainduration = (0.023+((1 - memWriteDel)/20)); //sec.
        graindurjitter = 0.1;
        density = cntrlLev;

        // L = buffer dimension in seconds
        L = ma.SR*bufferDim;
        // tableMax = table Max Dimension
        tableMax = 192000*bufferDim;
        // Write index - ramp 0 to L
        wIdx = (+(1) : %(L)) ~ _ : int;
        buffer(p, x) = it.frwtable(3, tableMax, .0, wIdx, x, p);
        // Hanning window Equation
        hann(x) = sin(ma.frac(x) * ma.PI) ^ 2.0;
        // noise generation for this instance
        iNoise = no.noise;
        // Position of the grain in the Buffer
        timePhase = (mempointer)+((iNoise*mempointerjitter)*L);
        fixedDimension = ma.SR/10;
        frequency = ma.SR/(fixedDimension);
        // two Heads for the read
        // 0¬∞
        ph1 = os.phasor(1, frequency);
        // 180*
        ph2 = ma.frac(.5 + ph1);
        // Buffer positions = Position in the Buffer + Grain Read
        pos1 = ba.sAndH(ph1 < ph1', timePhase) + ph1*(fixedDimension);
        pos2 = ba.sAndH(ph2 < ph2', timePhase) + ph2*(fixedDimension);
        // Noises of this Instance
        iNoise1 = ba.sAndH(ph1 < ph1', iNoise);
        iNoise2 = ba.sAndH(ph2 < ph2', iNoise);
        // variableDimension = grain.duration(variable) + grain.dur.jitter
        graindurjitterfunc = (grainduration*1000)*(iNoise1*graindurjitter);
        variableDimension1(x) = x*((1+(grainduration*1000))+(graindurjitterfunc)) : min(1);
        variableDimension2(x) = x*((1+(grainduration*1000))+(graindurjitterfunc)) : min(1);
        head1 = hann(ph1: variableDimension1) * buffer(pos1);
        head2 = hann(ph2: variableDimension2) * buffer(pos2);
    };
//process = granular_sampling;
